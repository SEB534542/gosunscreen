// Package gosunscreen monitors light and moves the Sunscreen accordingly through GPIO
package main

import (
	"encoding/csv"
	"encoding/json"
	"fmt"
	"html/template"
	"io/ioutil"
	"log"
	"net/http"
	"net/smtp"
	"os"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/SEB534542/seb"
	"github.com/kelvins/sunrisesunset"
	"github.com/satori/go.uuid"
	"github.com/stianeikeland/go-rpio/v4"
	"golang.org/x/crypto/bcrypt"
)

// LightSensor represents a physical lightsensor for which data can be collected through the corresponding GPIO pin.
type LightSensor struct {
	PinLight              rpio.Pin      // pin for retrieving light value
	Interval              time.Duration // Interval for checking current light in seconds
	timesGood             int           // Max measured light value that counts as "good weather"
	LightGoodThreshold    int           // Number of times light should be below lightGoodValue
	LightNeutralValue     int           // Max measured light value that counts as "neutral weather"
	LightNeutralThreshold int           // Number of times light should be above lightNeutralValue
	LightBadValue         int           // max measured light value that counts as "bad weather"
	LightBadThreshold     int           // number of times light should be above lightBadValue
	AllowedOutliers       int           // Number of outliers accepted in the measurement
	Data                  []int         // collected light values
	LightFactor           int           // Factor for correcting the measured analog light value
}

// Sunscreen represents a physical Sunscreen that can be controlled through 2 GPIO pins: one for moving it up, and one for moving it down.
type Sunscreen struct {
	Id            int           // Autogenerated ID for sunscreen
	Name          string        // Name of sunscreen
	Mode          string        // Mode of Sunscreen auto or manual
	Position      string        // Current position of Sunscreen
	DurDown       time.Duration // Duration to move Sunscreen down
	DurUp         time.Duration // Duration to move Sunscreen up
	PinDown       rpio.Pin      // GPIO pin for moving sunscreen down
	PinUp         rpio.Pin      // GPIO pin for moving sunscreen up
	AutoStart     bool          // If true, Start is calculated based on config.Location.GetSunriseSunset() and SunStart
	AutoStop      bool          // If true, Stop is calculated based on config.Location.GetSunriseSunset() and SunStop
	SunStart      time.Duration // Duration after Sunrise to determine Start
	SunStop       time.Duration // Duration after before Sunset to determine Stop
	Start         time.Time     // Time after which Sunscreen can shine on the Sunscreen area
	Stop          time.Time     // Time after which Sunscreen no can shine on the Sunscreen area
	StopThreshold time.Duration // Duration before Stop that Sunscreen no longer should go down
}

type Site struct {
	Sunscreens  []*Sunscreen
	LightSensor *LightSensor
}

// General constants
const (
	up       = "up"
	down     = "down"
	unknown  = "unknown"
	auto     = "auto"
	manual   = "manual"
	maxCount = 9999999
)

var (
	mu sync.Mutex
)

func init() {

}

func main() {

}




// MaxIntSlice receives variadic parameter of integers and return the highest integer
func MaxIntSlice(xi ...int) int {
	var max int
	for i, v := range xi {
		if i == 0 || v > max {
			max = v
		}
	}
	return max
}

// SaveToJson takes an interface and stores it into the filename
func SaveToJson(i interface{}, fileName string) {
	bs, err := json.Marshal(i)
	if err != nil {
		log.Fatal(err)
	}
	err = ioutil.WriteFile(fileName, bs, 0644)
	if err != nil {
		log.Fatal("Error", err)
	}
}

// SendMail sends mail to
func sendMail(subj, body string) {
	if config.EnableMail {
		//Format message
		var msgTo string
		for i, s := range config.MailTo {
			if i != 0 {
				msgTo = msgTo + ","
			}
			msgTo = msgTo + s
		}

		msg := []byte("To:" + msgTo + "\r\n" +
			"Subject:" + subj + "\r\n" +
			"\r\n" + body + "\r\n")

		// Set up authentication information
		auth := smtp.PlainAuth("", config.MailUser, config.MailPass, config.MailHost)

		// Connect to the server, authenticate, set the sender and recipient,
		// and send the email all in one step.
		err := smtp.SendMail(fmt.Sprintf("%v:%v", config.MailHost, config.MailPort), auth, config.MailFrom, config.MailTo, msg)
		if err != nil {
			log.Println("Unable to send mail:", err)
			return
		}
		log.Println("Send mail to", config.MailTo)
	}
}

func readCSV(file string) [][]string {
	// Read the file
	f, err := os.Open(file)
	if err != nil {
		f, err := os.Create(file)
		if err != nil {
			log.Fatal("Unable to create csv", err)
		}
		f.Close()
		return [][]string{}
	}
	defer f.Close()
	r := csv.NewReader(f)
	lines, err := r.ReadAll()
	if err != nil {
		log.Fatal(err)
	}
	return lines
}

func appendCSV(file string, newLines [][]string) {

	// Get current data
	lines := readCSV(file)

	// Add new lines
	lines = append(lines, newLines...)

	// Write the file
	f, err := os.Create(file)
	if err != nil {
		log.Fatal(err)
	}
	w := csv.NewWriter(f)
	if err = w.WriteAll(lines); err != nil {
		log.Fatal(err)
	}
}

// strToInt transforms string to an int and returns a positive int or zero
func strToInt(s string) (int, error) {
	i, err := strconv.Atoi(s)
	if err != nil {
		return 0, err
	}
	if i < 0 {
		return 0, err
	}
	return i, err
}

// CheckErr evaluates err for errors (not nil)
// and triggers a log.Panic containing the error.
func checkErr(err error) {
	if err != nil {
		log.Panic("Error:", err)
	}
	return
}

// sIndex retrieves the index of the corresponding Sunscreen Id within the site
func (site *Site) sIndex(id int) (int, error) {
	for i, s := range site.Sunscreens {
		if s.Id == id {
			return i, nil
		}
	}
	return 0, fmt.Errorf("Id %v not found", id)
}
